// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: checkout.sql

package sqlc

import (
	"context"
	"time"
)

const insertTransaction = `-- name: InsertTransaction :one

INSERT INTO "order" (
    description,
    transaction_date,
    transaction_value
) VALUES (
    $1::VARCHAR,
    $2::TIMESTAMP,
    $3::FLOAT
) RETURNING id
`

type InsertTransactionParams struct {
	Description      string
	TransactionDate  time.Time
	TransactionValue float64
}

// ---------------
// -- INSERTS ----
// ---------------
func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) (int64, error) {
	row := q.queryRow(ctx, q.insertTransactionStmt, insertTransaction, arg.Description, arg.TransactionDate, arg.TransactionValue)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const selectTransactions = `-- name: SelectTransactions :many


SELECT 
    id,
    description,
    transaction_date::TIMESTAMP AS transaction_date,
    transaction_value
FROM
    "order"
`

type SelectTransactionsRow struct {
	ID               int64
	Description      string
	TransactionDate  time.Time
	TransactionValue float64
}

// ---------------
// -- INSERTS ----
// ---------------
// ---------------
// -- SELECTS ----
// ---------------
func (q *Queries) SelectTransactions(ctx context.Context) ([]SelectTransactionsRow, error) {
	rows, err := q.query(ctx, q.selectTransactionsStmt, selectTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectTransactionsRow{}
	for rows.Next() {
		var i SelectTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.TransactionDate,
			&i.TransactionValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTransactionsTotal = `-- name: SelectTransactionsTotal :one
SELECT 
    count(id) AS total
FROM
    "order"
`

func (q *Queries) SelectTransactionsTotal(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.selectTransactionsTotalStmt, selectTransactionsTotal)
	var total int64
	err := row.Scan(&total)
	return total, err
}
